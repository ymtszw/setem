const Parser = require("tree-sitter");
const Elm = require("tree-sitter-elm");
const fs = require("fs");
const path = require("path");
const glob = require("glob");
const assert = require("assert").strict;
const crypto = require("crypto");

module.exports = {
  generate,
  resolvePaths,
  resolveDependencies,
  getIdentifiersAndEnsureCache,
};

/**
 * Generates record setter module source code.
 * @param {string[]} filepaths File paths to traverse.
 * @param {string} moduleName Module name to render. Defaults to "RecordSetter"
 * @param {string} prefix Function prefix. Defaults to "s_"
 * @param {string} elmJsonFile Path to elm.json file. If not given, it does not generate setters from dependencies
 * @returns string
 */
function generate(
  filepaths = [],
  moduleName = "RecordSetter",
  prefix = "s_",
  elmJsonFile = null
) {
  const uniqIdentifiers = [filepaths].flat().reduce(reducePerFile, new Set());
  const dependencyIdentifiers = collectIdentifiersFromDependencies(elmJsonFile);
  const sortedUniqIdentifiers = [
    ...new Set([...uniqIdentifiers, ...dependencyIdentifiers]),
  ].sort();
  const setters = sortedUniqIdentifiers.map(setterDefinition(prefix));
  return [moduleDeclaration(moduleName), ...setters].join("\n\n");
}

function reducePerFile(identifierSet, filepath) {
  const abspath = path.resolve(filepath);
  const source = fs.readFileSync(abspath, { encoding: "utf8" });
  return sourceToIdentifiers(source, identifierSet);
}

const parser = new Parser();
parser.setLanguage(Elm);

function sourceToIdentifiers(source, identifierSet = new Set()) {
  const tree = parser.parse(source);
  tree.rootNode
    .descendantsOfType(["field_type", "field", "record_pattern"])
    .flatMap((f) => {
      if (f.type === "record_pattern") {
        return f.descendantsOfType(["lower_case_identifier"]);
      } else {
        // Use only first lower_case_identifier before colon or equal in field def/expr
        return f.children.find((c) => c.type === "lower_case_identifier") || [];
      }
    })
    .forEach((identifier) => {
      identifierSet.add(identifier.text);
    });
  return identifierSet;
}

function setterDefinition(prefix) {
  return function (recordFieldIdentifier) {
    return `${prefix}${recordFieldIdentifier} : a -> { b | ${recordFieldIdentifier} : a } -> { b | ${recordFieldIdentifier} : a }
${prefix}${recordFieldIdentifier} value__ record__ =
    { record__ | ${recordFieldIdentifier} = value__ }
`;
  };
}

function moduleDeclaration(moduleName) {
  return `-- This module is generated by \`setem\` command. DO NOT edit manually!


module ${moduleName} exposing (..)
`;
}

/**
 * Resolves and returns absolute paths of input Elm source files.
 * @param {string[]} paths List of relative Elm source files retrieved from command line arguments. If empty, it enumerates files derived from `elmJsonFile`.
 * @param {string} elmJsonFile Path to elm.json file. Defaults to "./elm.json"
 * @returns string[]
 */
function resolvePaths(paths, elmJsonFile = "./elm.json") {
  if (paths.length === 0) {
    return collectAllSourcePathsFromElmJson(elmJsonFile);
  } else {
    return [...new Set(expandDirs(paths))];
  }
}

function collectAllSourcePathsFromElmJson(elmJsonFile) {
  const elmJson = getElmJson(elmJsonFile);
  const elmProjectDir = path.dirname(elmJsonFile);
  const sourceDirectories = elmJson["source-directories"].map((dir) => {
    return path.resolve(elmProjectDir, dir);
  });
  const testDirectory = path.resolve(elmProjectDir, "tests");
  return [...new Set(expandDirs([...sourceDirectories, testDirectory]))];
}

function getElmJson(elmJsonFile) {
  const elmJsonFileAbs = path.resolve(elmJsonFile);
  const elmJsonRaw = fs.readFileSync(elmJsonFileAbs, { encoding: "utf8" });
  const elmJson = JSON.parse(elmJsonRaw);
  assert.equal(
    elmJson.type,
    "application",
    "setem should not be used in package, to avoid module name conflict!"
  );
  return elmJson;
}

function expandDirs(paths) {
  return paths.flatMap((p) => {
    const stats = fs.statSync(p);
    if (stats.isDirectory()) {
      return glob.sync(path.resolve(p, "**", "*.elm"));
    } else {
      return path.resolve(p);
    }
  });
}

function collectIdentifiersFromDependencies(elmJsonFile) {
  if (elmJsonFile) {
    const dependencies = resolveDependencies(elmJsonFile);
    const cacheFile = dependencyIdentifierCacheFile(elmJsonFile, dependencies);
    return getIdentifiersAndEnsureCache(dependencies, cacheFile);
  } else {
    return [];
  }
}

function dependencyIdentifierCacheFile(elmJsonFile, dependencies) {
  const elmProjectDir = path.dirname(elmJsonFile);
  const dependenciesHash = crypto
    .createHash("md5")
    .update(dependencies.toString())
    .digest("hex");

  return path.resolve(
    elmProjectDir,
    "elm-stuff",
    "setem",
    "cache",
    `${dependenciesHash}.txt`
  );
}

/**
 * Returns identifiers from dependencies, and save them to `cacheFile`.
 * If `cacheFile` already exists, reads from it and do not re-generate.
 * @param {string[]} dependencies Paths to dependency directories in ELM_HOME.
 * @param {string} cacheFile A path of cache file which we save identifiers to.
 * @returns string[]
 */
function getIdentifiersAndEnsureCache(dependencies, cacheFile) {
  if (fs.existsSync(cacheFile)) {
    return fs
      .readFileSync(cacheFile, { encoding: "utf8" })
      .split("\n")
      .filter((s) => s !== "");
  } else {
    const dependencyIdentifiers = dependencies.reduce(
      reducePerDependency,
      new Set()
    );
    const sortedIdentifiers = [...dependencyIdentifiers].sort();
    fs.mkdirSync(path.dirname(cacheFile), { recursive: true });
    fs.writeFileSync(cacheFile, sortedIdentifiers.join("\n"));
    return sortedIdentifiers;
  }
}

function reducePerDependency(identifierSet, dependencyDir) {
  const dependencySourcePattern = path.resolve(
    dependencyDir,
    "src",
    "**",
    "*.elm"
  );
  return glob
    .sync(dependencySourcePattern)
    .reduce(reducePerFile, identifierSet);
}

/**
 * Resolves and returns absolute paths of versioned dependency directories.
 * @param {string} elmJsonFile Path to elm.json file.
 * @returns string[]
 */
function resolveDependencies(elmJsonFile) {
  const elmJson = getElmJson(elmJsonFile);
  const elmVersion = elmJson["elm-version"];
  const elmHome =
    process.env.ELM_HOME || path.resolve(process.env.HOME, ".elm"); // XXX Windows aren't supported
  const packagesDir = path.resolve(elmHome, elmVersion, "packages");
  return [
    ...fromDependencyObject(elmJson["dependencies"].direct, packagesDir),
    ...fromDependencyObject(elmJson["dependencies"].indirect, packagesDir),
    ...fromDependencyObject(elmJson["test-dependencies"].direct, packagesDir),
    ...fromDependencyObject(elmJson["test-dependencies"].indirect, packagesDir),
  ];
}

function fromDependencyObject(obj, packagesDir) {
  return Object.entries(obj).map(([authorAndPackage, version]) => {
    return path.resolve(packagesDir, authorAndPackage, version);
  });
}
