const Parser = require("tree-sitter");
const Elm = require("tree-sitter-elm");
const fs = require("fs");
const path = require("path");
const chalk = require("chalk");
const glob = require("glob");

module.exports = {
  generate,
  resolvePaths,
};

/**
 * Generates record setter module source code.
 * @param {string[]} filepaths File paths to traverse.
 * @param {string} moduleName Module name to render. Defaults to "RecordSetter"
 * @param {string} prefix Function prefix. Defaults to "s_"
 * @returns string
 */
function generate(filepaths = [], moduleName = "RecordSetter", prefix = "s_") {
  const uniqIdentifiers = [filepaths].flat().reduce(reducePerFile, new Set());
  const sortedUniqIdentifiers = [...uniqIdentifiers].sort();
  const setters = sortedUniqIdentifiers.map(setterDefinition(prefix));
  return [moduleDeclaration(moduleName), ...setters].join("\n\n");
}

const cwd = process.cwd();
function reducePerFile(identifierSet, filepath) {
  const abspath = path.resolve(cwd, filepath);
  const source = fs.readFileSync(abspath, { encoding: "utf8" });
  return sourceToIdentifiers(source, identifierSet);
}

const parser = new Parser();
parser.setLanguage(Elm);

function sourceToIdentifiers(source, identifierSet = new Set()) {
  const tree = parser.parse(source);
  tree.rootNode
    .descendantsOfType(["field_type", "field", "record_pattern"])
    .flatMap((f) => {
      if (f.type === "record_pattern") {
        return f.descendantsOfType(["lower_case_identifier"]);
      } else {
        // Use only first lower_case_identifier before colon or equal in field def/expr
        return f.children.find((c) => c.type === "lower_case_identifier") || [];
      }
    })
    .forEach((identifier) => {
      identifierSet.add(identifier.text);
    });
  return identifierSet;
}

function setterDefinition(prefix) {
  return function (recordFieldIdentifier) {
    return `${prefix}${recordFieldIdentifier} : a -> { b | ${recordFieldIdentifier} : a } -> { b | ${recordFieldIdentifier} : a }
${prefix}${recordFieldIdentifier} value__ record__ =
    { record__ | ${recordFieldIdentifier} = value__ }
`;
  };
}

function moduleDeclaration(moduleName) {
  return `-- This module is generated by \`setem\` command. DO NOT edit manually!


module ${moduleName} exposing (..)
`;
}

/**
 * Resolves and returns absolute paths of input Elm source files.
 * @param {string[]} paths List of relative Elm source files retrieved from command line arguments. If empty, it enumerates files derived from `elmJsonFile`.
 * @param {string} elmJsonFile Path to elm.json file. Defaults to "./elm.json"
 * @returns string[]
 */
function resolvePaths(paths, elmJsonFile = "./elm.json") {
  if (paths.length === 0) {
    return collectAllSourcePathsFromElmJson(elmJsonFile);
  } else {
    return [...new Set(expandDirs(paths))];
  }
}

function collectAllSourcePathsFromElmJson(elmJsonFile) {
  const elmJson = getElmJson(elmJsonFile);
  const elmProjectDir = path.dirname(elmJsonFile);
  const sourceDirectories = elmJson["source-directories"].map((dir) => {
    return path.resolve(elmProjectDir, dir);
  });
  const testDirectory = path.resolve(elmProjectDir, "tests");
  return [...new Set(expandDirs([...sourceDirectories, testDirectory]))];
}

function getElmJson(elmJsonFile) {
  const elmJsonFileAbs = path.resolve(cwd, elmJsonFile);
  const elmJsonRaw = fs.readFileSync(elmJsonFileAbs, { encoding: "utf8" });
  return JSON.parse(elmJsonRaw);
}

function expandDirs(paths) {
  return paths.flatMap((p) => {
    const stats = fs.statSync(p);
    if (stats.isDirectory()) {
      return glob.sync(path.resolve(p, "**/*.elm"));
    } else {
      return path.resolve(process.cwd(), p);
    }
  });
}
