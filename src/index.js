const Parser = require("tree-sitter");
const Elm = require("@elm-tooling/tree-sitter-elm");
const fs = require("node:fs");
const path = require("node:path");
const glob = require("glob");
const assert = require("node:assert").strict;
const crypto = require("node:crypto");
const child_process = require("node:child_process");

module.exports = {
  generate,
  resolvePaths,
  resolveDependencies,
  getIdentifiersAndEnsureCache,
};

/**
 * Generates record setter module source code.
 * @param {string[]} filepaths File paths to traverse.
 * @param {string} moduleName Module name to render. Defaults to "RecordSetter"
 * @param {string} prefix Function prefix. Defaults to "s_"
 * @param {string} elmJsonFile Path to elm.json file. If not given, it does not generate setters from dependencies
 * @param {boolean} hasExplicitPaths If `true`, it does not generate setters from dependencies. (For backward compatibility)
 * @returns string
 */
function generate(filepaths, moduleName = "RecordSetter", prefix = "s_", elmJsonFile = null, hasExplicitPaths) {
  const uniqIdentifiers = [filepaths].flat().reduce(reducePerFile, new Set());
  const dependencyIdentifiers = collectIdentifiersFromDependencies(elmJsonFile, hasExplicitPaths);
  const sortedUniqIdentifiers = [...new Set([...uniqIdentifiers, ...dependencyIdentifiers])].sort();
  const setters = sortedUniqIdentifiers.map(setterDefinition(prefix));
  return [moduleDeclaration(moduleName), ...setters].join("\n\n");
}

function reducePerFile(identifierSet, filepath) {
  const abspath = path.resolve(filepath);
  const source = fs.readFileSync(abspath, { encoding: "utf8" });
  return sourceToIdentifiers(source, identifierSet);
}

const parser = new Parser();
parser.setLanguage(Elm);

function sourceToIdentifiers(source, identifierSet = new Set()) {
  const tree = parser.parse(source);
  tree.rootNode
    .descendantsOfType(["field_type", "field", "record_pattern"])
    .flatMap((f) => {
      if (f.type === "record_pattern") {
        return f.descendantsOfType(["lower_case_identifier"]);
      } else {
        // Use only first lower_case_identifier before colon or equal in field def/expr
        return f.children.find((c) => c.type === "lower_case_identifier") || [];
      }
    })
    .forEach((identifier) => {
      identifierSet.add(identifier.text);
    });
  return identifierSet;
}

function setterDefinition(prefix) {
  return (
    recordFieldIdentifier,
  ) => `${prefix}${recordFieldIdentifier} : a -> { b | ${recordFieldIdentifier} : a } -> { b | ${recordFieldIdentifier} : a }
${prefix}${recordFieldIdentifier} value__ record__ =
    { record__ | ${recordFieldIdentifier} = value__ }
`;
}

function moduleDeclaration(moduleName) {
  return `-- This module is generated by \`setem\` command. DO NOT edit manually!


module ${moduleName} exposing (..)
`;
}

/**
 * Resolves and returns absolute paths of input Elm source files.
 * @param {string[]} paths List of relative Elm source files retrieved from command line arguments. If empty, it enumerates files derived from `elmJsonFile`.
 * @param {string} elmJsonFile Path to elm.json file. Defaults to "./elm.json"
 * @returns string[]
 */
function resolvePaths(paths, elmJsonFile = "./elm.json") {
  if (paths.length === 0) {
    return collectAllSourcePathsFromElmJson(elmJsonFile);
  } else {
    return [...new Set(expandDirs(paths))];
  }
}

function collectAllSourcePathsFromElmJson(elmJsonFile) {
  const elmJson = getElmJson(elmJsonFile);
  const elmProjectDir = path.dirname(elmJsonFile);
  const sourceDirectories = elmJson["source-directories"].map((dir) => {
    return path.resolve(elmProjectDir, dir);
  });
  const testDirectory = path.resolve(elmProjectDir, "tests");
  return [...new Set(expandDirs([...sourceDirectories, testDirectory]))];
}

function getElmJson(elmJsonFile) {
  const elmJsonFileAbs = path.resolve(elmJsonFile);
  const elmJsonRaw = fs.readFileSync(elmJsonFileAbs, { encoding: "utf8" });
  const elmJson = JSON.parse(elmJsonRaw);
  assert.equal(elmJson.type, "application", "setem should not be used in package, to avoid module name conflict!");
  return elmJson;
}

function expandDirs(paths) {
  return paths.flatMap((p) => {
    if (!fs.existsSync(p)) {
      return [];
    } else if (fs.statSync(p).isDirectory()) {
      return glob.sync(path.resolve(p, "**", "*.elm")).sort(); // Since node-glob 9.0, glob.sync() does not guarantee the order of results.
    } else {
      return path.resolve(p);
    }
  });
}

function collectIdentifiersFromDependencies(elmJsonFile, hasExplicitPaths) {
  if (!hasExplicitPaths && elmJsonFile) {
    const elmHome =
      (process.env.ELM_HOME && path.resolve(process.env.ELM_HOME)) ||
      (process.env.HOME && path.resolve(process.env.HOME, ".elm")) ||
      assert.fail("$HOME or $ELM_HOME must exist!"); // XXX Windows aren't supported
    const dependencies = resolveDependencies(elmJsonFile, elmHome);
    const dependenciesDownloaded = ensureDependenciesDownloaded(elmJsonFile, elmHome, dependencies);
    const cacheFile = dependencyIdentifierCacheFile(elmJsonFile, dependencies);
    return getIdentifiersAndEnsureCache(dependencies, cacheFile, dependenciesDownloaded);
  } else {
    return [];
  }
}

/**
 * Ensure all dependencies are downloaded. If not, download the dependencies by compiling a dummy app.
 * @param {string} elmJsonFile Path to elm.json file
 * @param {string} elmHome Absolute path to elm home directory
 * @param {string[]} dependencies Paths to dependency directories
 * @returns boolean flag indicating whether dependencies are just downloaded or not
 */
function ensureDependenciesDownloaded(elmJsonFile, elmHome, dependencies) {
  assert.equal(path.isAbsolute(elmHome), true);
  if (dependencies.some((dep) => !fs.existsSync(dep))) {
    console.log("[setem] Some dependencies are not downloaded yet. Downloading with dummy app...");
    downloadDependenciesUsingDummyElmApp(elmJsonFile, elmHome);
    return true;
  } else {
    return false;
  }
}

function downloadDependenciesUsingDummyElmApp(elmJsonFile, elmHome) {
  assert.equal(path.isAbsolute(elmHome), true);
  const elmJsonFileAbs = path.resolve(elmJsonFile);
  const elmJson = JSON.parse(fs.readFileSync(elmJsonFileAbs, { encoding: "utf8" }));
  elmJson["source-directories"] = ["dummySrc"];

  // Make all dependencies as direct, so that it can be downloaded at once;
  elmJson["dependencies"].direct = {
    ...elmJson["dependencies"].direct,
    ...elmJson["dependencies"].indirect,
    ...elmJson["test-dependencies"].direct,
    ...elmJson["test-dependencies"].indirect,
  };
  elmJson["dependencies"].indirect = {};
  elmJson["test-dependencies"].direct = {};
  elmJson["test-dependencies"].indirect = {};

  // Generate dummy app in elm-stuff/setem/dummy_app_<project name>/
  const elmProjectDir = path.dirname(elmJsonFileAbs);
  const dummyElmAppName = `dummy_app_${path.basename(elmProjectDir)}`;
  const dummyElmAppDir = path.join(elmProjectDir, "elm-stuff", "setem", dummyElmAppName);
  const dummySrcDir = path.join(dummyElmAppDir, "dummySrc");
  fs.mkdirSync(dummySrcDir, { recursive: true });
  const dummyElmJsonFile = path.join(dummyElmAppDir, "elm.json");
  fs.writeFileSync(dummyElmJsonFile, JSON.stringify(elmJson, null, 4));
  const dummyMainFile = path.join(dummySrcDir, "SetemDummyMain.elm");
  fs.writeFileSync(dummyMainFile, minimulCompileableApp);

  // Compile the dummy app
  const customPath = pathWithPossibleNodeModulesBinDirs();
  const customEnv = { ...process.env, PATH: customPath, ELM_HOME: elmHome };
  child_process.execFileSync("elm", ["make", dummyMainFile, "--output=/dev/null"], {
    cwd: dummyElmAppDir,
    stdio: "inherit",
    env: customEnv,
  });
}

function dependencyIdentifierCacheFile(elmJsonFile, dependencies) {
  const elmProjectDir = path.dirname(elmJsonFile);
  const dependenciesHash = crypto.createHash("md5").update(dependencies.toString()).digest("hex");

  return path.resolve(elmProjectDir, "elm-stuff", "setem", "cache", `${dependenciesHash}.txt`);
}

/**
 * Returns identifiers from dependencies, and save them to `cacheFile`.
 * If `cacheFile` already exists, reads from it and do not re-generate.
 * @param {string[]} dependencies Paths to dependency directories in ELM_HOME.
 * @param {string} cacheFile A path of cache file which we save identifiers to.
 * @param {boolean} dependenciesDownloaded Whether dependencies are just downloaded or not. If true, it ignores cache.
 * @returns string[]
 */
function getIdentifiersAndEnsureCache(dependencies, cacheFile, dependenciesDownloaded) {
  if (!dependenciesDownloaded && fs.existsSync(cacheFile)) {
    return fs
      .readFileSync(cacheFile, { encoding: "utf8" })
      .split("\n")
      .filter((s) => s !== "");
  } else {
    const dependencyIdentifiers = dependencies.reduce(reducePerDependency, new Set());
    const sortedIdentifiers = [...dependencyIdentifiers].sort();
    fs.mkdirSync(path.dirname(cacheFile), { recursive: true });
    fs.writeFileSync(cacheFile, sortedIdentifiers.join("\n"));
    return sortedIdentifiers;
  }
}

function reducePerDependency(identifierSet, dependencyDir) {
  const dependencySourcePattern = path.resolve(dependencyDir, "src", "**", "*.elm");
  return glob.sync(dependencySourcePattern).reduce(reducePerFile, identifierSet);
}

/**
 * Resolves and returns absolute paths of versioned dependency directories.
 * @param {string} elmJsonFile Path to elm.json file.
 * @param {string} elmHome Absolute path to elm home directory.
 * @returns string[]
 */
function resolveDependencies(elmJsonFile, elmHome) {
  assert.equal(path.isAbsolute(elmHome), true);
  const elmJson = getElmJson(elmJsonFile);
  const elmVersion = elmJson["elm-version"];
  const packagesDir = path.resolve(elmHome, elmVersion, "packages");
  return [
    ...fromDependencyObject(elmJson["dependencies"].direct, packagesDir),
    ...fromDependencyObject(elmJson["dependencies"].indirect, packagesDir),
    ...fromDependencyObject(elmJson["test-dependencies"].direct, packagesDir),
    ...fromDependencyObject(elmJson["test-dependencies"].indirect, packagesDir),
  ];
}

function fromDependencyObject(obj, packagesDir) {
  return Object.entries(obj).map(([authorAndPackage, version]) => {
    return path.resolve(packagesDir, authorAndPackage, version);
  });
}

function pathWithPossibleNodeModulesBinDirs() {
  let cwdOrAncestors = process.cwd();
  const ret = [];
  while (cwdOrAncestors !== path.dirname(cwdOrAncestors)) {
    ret.push(cwdOrAncestors);
    cwdOrAncestors = path.dirname(cwdOrAncestors);
  }
  const nodeModulesBinPaths = ret.map((cwdOrAncestor) => path.join(cwdOrAncestor, "node_modules", ".bin")).join(path.delimiter);
  return [process.env.PATH, nodeModulesBinPaths].join(path.delimiter);
}

/**
 * All it needs are prelude modules
 */
const minimulCompileableApp = `
module SetemDummyMain exposing (main)

main : Program () () Never
main =
  Platform.worker
    { init = \\_ -> ( (), Cmd.none )
    , update = \\_ _ -> ( (), Cmd.none )
    , subscriptions = \\_ -> Sub.none
    }
`;
